- - - ( Laravel Architecture ) - - -


** ( Understanding {index.php} ):

- "Bootstraps" the framework & calls

- Entry point of all "web requests"


* ( Code ):    

 use Illuminate\Foundation\Application;
 use Illuminate\Http\Request;

 define('LARAVEL_START', microtime(true));

 // Determine if the application is in maintenance mode...
 if (file_exists($maintenance = __DIR__.'/../storage/framework/maintenance.php')) {
     require $maintenance;
 }

 // Register the Composer autoloader...
 require __DIR__.'/../vendor/autoload.php';

 // Bootstrap Laravel and handle the request...
 /** @var Application $app */
 $app = require_once __DIR__.'/../bootstrap/app.php';

 $app->handleRequest(Request::capture());



* ( Bootstrap/app.php in index.php explanation ):   

 $app = require_once __DIR__.'/../bootstrap/app.php'; 
 // Creates an instance of the "Illuminate\Foundation\Application"


 $app -> handleRequest(Request::capture());
 // Captures the "Requests", using the method 




** ( Understanding {Illuminate\Foundation\Application}):    

- "Illuminate\Foundation\Application", is the "Service Container"   


- It contains "services" that are "registered(Instantiated)",

  e.g.. "App\HTTP\Kernel", where "handleRequest(Request::capture())"
         is originally from 


- By creating an "instance" of the "application", we're able to use 
  "services" that are "registered" within the "application/container" 




** ( Understanding {Bootstrap App.php}):   

- The "Bootstrap's app.php"...
• initializes application object / "Service Container"
• Prepares for Booting



* ( Code of app.php ):

 use Illuminate\Foundation\Application;
 use Illuminate\Foundation\Configuration\Exceptions;
 use Illuminate\Foundation\Configuration\Middleware;


 return Application::configure(basePath: dirname(__DIR__))
     ->withRouting(
         web: __DIR__.'/../routes/web.php',
         commands: __DIR__.'/../routes/console.php',
         health: '/up',
     )
     ->withMiddleware(function (Middleware $middleware): void {
         //
     })
     ->withExceptions(function (Exceptions $exceptions): void {
         //
     })->create();




** ( Understanding {Handle Request Method}):  

- handle request method purpose...   
• After running through the "application logic"
• It's Responsible for taking incoming "HTTP Requests" 
• then Converting "Requests" -> "Response"


- The "handleRequest(Request::capture());" under,
  "application.php", handles the "request" using 
  "HTTP Kernel", code...

  the "method" that "handles requests", is 
  "originally" from the "kernel"

  but by using the "contract(Interface)", 
  we're able to use it in the "application.php"

  The actual "implementation" is the "kernel" from "HTTP Dir",
  or "Illuminate\Foundation\Http\Kernel.php"
 



** ( Understanding {"Web Request" Handling Sequence} ):   

1) {Request} is Captured by... 

   // Called in index.php, but the implementation is in "application.php"
   → $app->handleRequest(Request::capture());

   // The Implementaion in "application.php (Illuminate\Foundation\Application)"
   → public function handleRequest(Request $request){...}



2) after {Request} is passed to, "handleRequest(Request $request){...}",
   this method passes the {Request} to...    
   
   /*
   Called under the handleRequest(){...} method, but the implementation is in "kernel.php"
   also... 
   → after route/controller method, generates a response, it moves outward through route's middleware,
   → then the send(); method is invoked on the response object( returned by handle(); method ),
   → then the final response is then delivered to the user's web browser, completing the lifecycle 
   */  
   → $response = $kernel->handle($request)->send();

   // The Implementation in "kernel.php (Illuminate\Foundation\Http)"
   → public function handle($request){...}



3) after {Request} is passed to, "handle($request){...}",
   this method passes the {Request} to...

   // Called under the handle($request){...} method, but the implementation is also in "kernel.php"
   → $response = $this->sendRequestThroughRouter($request);

   // The Implementation is in the same namespace, but different method
   → protected function sendRequestThroughRouter($request){...}



4) after Request is passed to, "sendRequestThroughRouter($request){...}",
   "this" method...
    • sends {Request} to the "application middleware stack" 
    • then, dispatches {Request} to the "matched router" 
    • then, {Request} will run through "route specific middleware"
    • then finally, {Request} is sent to a "Route Action / Controller"


   //Code: 
   → protected function sendRequestThroughRouter($request)
    {
     $this->app->instance('request', $request);

     Facade::clearResolvedInstance('request');

     $this->bootstrap();

     return (new Pipeline($this->app)) 
         ->send($request)
         ->through($this->app->shouldSkipMiddleware() ? [] : $this->middleware) //app middleware stack
         ->then($this->dispatchToRouter()); //request dispatched to router
     }




** ( Understanding {Middleware} ):

- "Laravel Middleware", acts as a "gatekeeper" that...
  • inspects 
  • filters 
  • decides

  if the "request" must "proceed" into "application / not" 

  it can "redirect" requests based on conditions, e.g..   
  • user authentication
  • authorization
  • etc... 


- "Middlewares" can be applied "globally" / "specifc routes",
  
  IF: 
  "request" successfully "passes" through all, "matched" route's 
  "middlewares"
  
  the "route / controller method", "executes" & "response"
  is sent back through the "middleware chain" 




** ( Understanding {bootsrap()} ):

- before request is sent to the router, this method is called,
  method: "$this->bootstrap();"
  ( under the, sendRequestThroughRouter($request){...} )
 
  it's responsible for "configuring & bootstrapping" important 
  parts of the framework, e.g.. Error handling, logging etc...



  //The actual Implementations of bootstrap, under in kernel.php (Illuminate\Foundation\Http)
1) Executes the bootstrapping process (if not done yet)
• Checks if the application has already been bootstrapped (hasBeenBootstrapped())
• If not, it runs all the bootstrappers by calling bootstrapWith() and passing them in

→ public function bootstrap() {
     if (! $this->app->hasBeenBootstrapped()) {
     $this->app->bootstrapWith($this->bootstrappers());
    }
   }



2) Provides the list of classes that will be "bootstrapped"
• Just returns the list/array of bootstrapper classes 
  e.g.. LoadEnvironmentVariables, HandleExceptions, RegisterProviders, etc...

→ protected function bootstrappers(){ 
    return $this->bootstrappers; 
  }



3) The actual "bootstrapper classes", that laravel bootstraps 
   in order to prepare the framework

→ protected $bootstrappers = [
   \Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class,
   \Illuminate\Foundation\Bootstrap\LoadConfiguration::class,
   \Illuminate\Foundation\Bootstrap\HandleExceptions::class,
   \Illuminate\Foundation\Bootstrap\RegisterFacades::class,
   \Illuminate\Foundation\Bootstrap\RegisterProviders::class,
   \Illuminate\Foundation\Bootstrap\BootProviders::class,
  ];



  ( Deep explanation of each Bootstrapper Classes ):    

• ( "LoadEnvironmentVariables" ):
  Loads values from your {.env} file into PHP's environment 
  so they can be read by the config system

  
• ( "LoadConfiguration" ):
  Loads all the configuration files from {config/} & puts 
  them into the application's config repository


• ( "HandleExceptions" ):
  Registers and configures Laravel's exception handler 
  so errors are caught & rendered nicely


• ( "RegisterFacades" ):
  Sets up the Facade system (links Facades to the service container)


• ( "RegisterProviders" ):
  Registers all of your application's service providers (from {config/app.php})


• ( "BootProviders" ):
  Calls the {boot()} method on every registered service provider




** ( Understanding {Service Providers} ):

- One of the keysteps during the "start-up / bootstrapping" 
  process involves setting up "service providers"


- "Service providers" can be perceived as "helpers", that gets 
  everything ready for your "application" to run properly

  they take care of setting up all the major parts of your application
  e.g..
  • database
  • ques
  • validation
  • routing
  • etc...


- Note:
  
• In the situation of trying to use services from other 
  providers in the register method,
  
  the register method doesn't guarantee, that all providers 
  have been loaded yet

  the services you attempt to use, might not be available yet


• any code that depends on services from other providers,
  should be placed in the "Boot method"

  the register method should just be used to registering services,
  within the container



  ( Code ):    
  
  <?php 

  namespace App\Providers 

  use Illuminate\Support\ServiceProvider;

  class AppServiceProvider extends ServiceProvider 
  {
    /**
     * Register any application services
     */
    public function register(): void 
    {
      //
    }

    /**
     * Bootstrap any application services
     */
     public function boot(): void
     {
       //
     }
  }




** ( Understanding {RegisterProviders} ):

- the "register method", is used to "register / bind", "services / classes"
  into the "service container"


- Back to the "Bootstrappers" under the...
  "Illuminate\Foundation\Bootstrap\RegisterProviders::class"
  
  the method: "public function bootstrap(Application $app){...}"
  gets called when the application is bootstrapping, 
  
  under it, "$app->registerConfiguredProviders();", this method...
  • uses the, "ProviderRepository" 
  • then calls the "public function load(array $providers){...}" method
    on that repository
  
  the load method: "public function load(array $providers){...}",
  essentially...
  • loads the providers
  • registers the providers, calling the register method
    on the application instance 

  the register method, "public function register($provider, $force = false){...}",
  defined in the "Application.php"...
  • checks if a "provider" is already "registered / not"
  • then eventually calls the "register method" on the "service provider"




** ( Understanding {BootProviders} ):

- after all "Service Providers" have been "Registered" they are "booted",
  • "Register" each "service provider"
  • Then, "Boot" each "service provider"
  
  the "boot method" is the "action method"

  Back to the "Bootstrappers" under the...
  "Illuminate\Foundation\Bootstrap\BootProviders::class",
  is what calls the boot method, on the "service provider"

  public function bootstrap(Application $app){ $app->boot(); }
  //calls the "boot method" from the "application object"

  the boot method: "public function boot(){...}", defined in the "Application.php"...
  • checks if a "service provider" has already been booted or not 
  • then, calls the "bootProvider()" method on that "service provider"

  the boot provider method, "protected function bootProvider(ServicePorvider $Provider){...}",
  defined in the "Application.php", calls the "boot method" on the "provider object"




** ( Understanding {Service Containers} ):

- "Service Container" is the dependency injection container,
   
  In the "application.php application class", it extends the "Container",
  essentially the "application class" is also the "Service Container"




** ( Understanding {"Console Request" Handling Sequence} & {artisan} ):

- {Console Requests} are not "processed" by the "index.php", 
  instead the {console requests} enter the application,
  through the "artisan CLI" 
  
  which "bootstraps" the "application" using the "console kernel"

  The "Command Syntax" is...
  • php artisan {namespace}:{commands available to namespace}


- "Artisan Commands" are handle by the "Artisan File", within,
  Laravel's root project directory

  it is a script( just like index.php )...
  • creates
  • configures
  • gets the application instance

  but calls the "handleCommand" method instead of the "handleRequest"
  ( which is defined in the "Application.php" )


- the "handleCommand", creates the console kernel & then calls
  the "handle();" method, defined from the "kernel object"
  
  ( and the process is similar to the "index.php" )



* ( Samples of Artisan Commands ):   

 • CMD: php artisan list {-h} 
 // see list of commands, adding {-h flag} gives 
 // specific instruction about the command 


 • CMD: php artisan route:list 
 // displays list of available routes ( both application & vendor ),
 // adding → --except-vendor, excludes the vendor routes    


 • php artisan list {namespace}
 // show list of commands available to the namespace,
 // adding → :{commands available to namespace} -h
 // gives more info about the specific command 
  



** ( Understanding {Kernels} ):

- kernels are the brains of the operation, "directing" how "requests" 
  are "handled"( albeit, "web request" / "console commands" )
- - - ( Laravel Blade Components ) - - -

- are "reusable view pieces", that allows to create, 
  cleaner & modular templates ( like a mini HTML page )

  this can be created w/...
  CMD #1: { php artisan make:component *component_name }
  CMD #2: { php artisan make:component *component_name --view }    
  (e.g.. component name, "Nav")

  the "CMD #1", creates 2 Files, the "component's class" & the "component's view",
  creating a {"Class Based Component"}, both files can be located at...
  • Component: [app/view/components/nav.php] = The Component's Class
  • View: [resrouces/views/components/nav.blade.php] = The Component's View

  the "CMD #2", creates only 1 File, the "component's view", 
  creating a {"Anonymous Component"}( a component w/o a class ) 


  (Note): 
  • The 1st time that "this" command is used, is where the "component directories" 
    will be created ( again, under "app" & "resources")  



- After creating this "components", they can be  "rendered / added" 
  in the "blade template" using this tag 
  ( they work similarly to PHPs {include() / require()})

  //IF: Component file is not on other directories
  • <x - *component_name />  
  
  //IF: Component file is on a another directory
  • <x - *directory . *component_name /> 




** ( Passing Data to the Components ):  

- There are 2 options to pass data to the components,  
  both options allows passed data, to be used by the 
  component
  
  • (Option1): 
    return view( *template_name , ["data" => "value"] )
  

  • (Option2): 
    <x - *component_name 
     '*$key/attribute' = "{{ $value }}" //Reads Values as Strings 
     ':*$key/attribute' = "$value" //Reads Values as PHP syntax / PHP expressions, etc.. 
    />
     



** ( Understanding $attributes[] & @props([]) ):  

- Values passed using Option2, are "stored" in what's called 
  the "Component Attribute Bag" or $attributes[](an assoc_array)

  and this Values can be used within the scope of the "component",
  by calling the *Key/attribute

- @props(['title', 'color' => 'blue']), is just a directive that
  allows to to define variables inside the component

  any key/value passed from the "<x-*component />" tag, but are already
  defined from the component's @props([]), are excluded from the 
  "Component Attribute Bag"  

  Note: The "$attributes" & "@props([])", are only available inside "component views"
        


  ( Example Code ):  

  {layout.blade.php}

  <x-home Key1 = "{{ $value }}" />
  <x-menu Key2 = "{{ $value }}" />
  <x-contact Key3 = "{{ $value }}" />



  {home, menu, contact, about_us & dashboard components}

  @props(['Key3' => 'Three'])

  <p> $attributes->get("Key1") </p>
  //Outputs: "1"

  <p>{{ $attributes }}</p>
  //Outputs all stored attributes, passsed in the specific component
  //Except Key3, because of the "props"

  <p>{{ $Key3 }}</p>
  //Outputs: "Three", from the Props
     



** ( Attributes Merge ):   

- Sample Usage...  

 • <x-button class = "bg-red-500" />

 • <button {{ $attributes->merge(['class' => 'px-4 py-2']) }} />

 • Result: <button class="px-4 py-2 bg-red-500"> 

 //Notes: any attributes defined in the specified class attribute, are now merged



- Tailwind Pre Cautions...

 • For "dynamic" class names, its better to use "Full Class Name"
   instead of "Modified Class Names" 
   ( unless you know tailwind & adding exclusions)

   e.g.. of "Modified Class Names", < class="bg-{{$color}}-100" />

   

 • to solve this dynamic case, we can create a lookup table, e.g..

   @php 
     $ColorClasses = [
     'green' => ['bg' => 'bg-green-100', 'text' => 'text-green-500'],
     'red' => ['bg' => 'bg-red-100', 'text' => 'text-red-500'], 
     ]
   @endphp


  <div class = "{{ ColorClasses[$color]['bg'] }}" />
  <div class = "{{ ColorClasses[$color]['text'] }}" />




** ( Introduction to Slot ):   

- Slots are placeholders inside Blade views that let you pass custom content into 
  a layout or component from where it's used. They act like variables that hold 
  the content between the <x-tag></x-tag>.


- Each <x-tag> (like <x-layout> or <x-home>) has its own slot scope — meaning the slot's 
  content and variables are restricted to that specific view file and can't be accessed 
  by other views.
  (Note: <x-tags> can be called from any Blade view.)

  

  ( Example #1: Separate Files ):  
   
   {other_file.blade.php}:

   <x-layout>
    
     <x-slot:title> This is my Title </x-slot:title>

     My-Layout //Default Slot Value for Layout

     <x-slot:prgrph> Lorem Ipsum, blah blah </x-slot:prgrph>

     <x-slot:value>{{ $this_value }}</x-slot:value>

   </x-layout>


   {layout.blade.php}:

   <h1>{{ $title }}</h1> // This is my Title
   <main>{{ $slot }}<main> // My-Layout
   <p>{{ $prgrph }}</p> // Lorem Ipsum, blah blah
   <p>{{ $value }}>/p> // *Outputs The Value Passed



  ( Example #2: Same File ):

   {home.blade.php}:

   <x-home>
     <x-slot:title> This is my Title </x-slot:title>

     My-Home //Default Slot Value for Home

     <x-slot:prgrph> Lorem Ipsum, blah blah </x-slot:prgrph>

     <x-slot:value>{{ $this_value }}</x-slot:value>
   </x-home>


   
   <h1>{{ $title }}</h1> // This is my Title
   <main>{{ $slot }}<main> // My-Home
   <p>{{ $prgrph }}</p> // Lorem Ipsum, blah blah
   <p>{{ $value }}>/p> // *Outputs The Value Passed 



   ( Shortcut ):

   - Note: This are the Same thing...
   

   • <x-home> 
      <x-slot:value>{{ $this_value }}</x-slot:value>
     </x-home>

   • <x-home :value="$this_value"></x-home>
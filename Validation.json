 - - - ( Laravel Validation ) - - -

** ( Return Type Declaration ): https://chatgpt.com/s/t_690ef53f2f0c8191a09845f4fb9ed7c4


** ( Validation Use-case Intro ):  

- Example: we have a "store method", in where we will apply and use the "validate method",
  validate method, is provided by the "Illuminate\Http\Request"

 IF: 
 validation rules pass, code will keep executing normally 

 ELSE:
 an "Illuminate\Validation\ValidationException" exception
 will be thrown & the proper error response will automatically
 be sent back to the user

 Example Exception(1): "traditional HTTP request"
 a redirect response to the previous URL will be generated

 Example Exception(2): "XHR request"
 a JSON response containing the validation error messages will be returned.

 ( Practice this in the house later ):



* ( Sample Validation Logic ):

public function store(Request $request): RedirectResponse
{
    $validated = $request->validate([
        'title' => 'required|unique:posts|max:255',
        'body' => 'required',
    ]);
 
    // The blog post is valid...
 
    return redirect('/posts');
}



* ( A Note on Optional Fields ):  

- for optional fields, mark "optional" request fields 
  as nullable, to consider null values as valid

$request->validate([
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
    'publish_at' => 'nullable|date',
]);




** ( Validation Error ):  

- IF: "requests fields", do not pass given validation rules...
→ Laravel redirects user to previous location
→ all of validation errors & request input, auto flashed to the session


- An {$errors instance} is shared w/all of "application's views", by the 
  "Illuminate\View\Middleware\ShareErrorsFromSession" middleware

  When this "middleware" is applied, an {$errors instance} will always 
  be available in the "Blade views" that are "rendered" by "routes" 
  under the "web" middleware group


- The {$errors instance} is an instance of "Illuminate\Support\MessageBag"



* ( @error directive ):   

- this "directive" can be used, to "quickly" determine if 
  "validation error messages" exists for a given "attribute"

  Within an "@error directive", you may echo the "$message var"
  to display the "error message"

  
  ( Example ):   

  // Using directive in views or components 
  // note: is-invalid, just turns the input label red

  <label for="title">Post Title</label>
 
  <input type="text" name="title" class="@error('title') is-invalid @enderror"/>
  
  @error('title')
      <div class="alert alert-danger">{{ $message }}</div>
  @enderror




** ( Repopulating Forms ):  

- When Laravel generates a redirect response due to a validation error

  // Continue after learning Laravel "Sessions"




** ( Form Request Validation ):  

- for more complex validation scenarios, you may wish to create a "form request"

  "Form requests", are "custom request classes" that "encapsulates" their own 
  "validation" & "authorization" logic

  the "command" to create one... CMD: {php artisan make:request *FileName}
  // this is stored in "app/Http/Requests directory", which is only present when
  // make:request is run once


-  Each form request generated by Laravel has two "methods"...

  • ( authorize method, Invoked First ):     
    responsible for determining if currently authenticated 
    user performs an action, represented by request 
    {"this method returns a boolean"}

  • ( rules method,  Invoked Last ):
    returns validation rules that should apply to the request's data

    these methods are invoked, when the "request" reaches the controller,
    where the "request file's namespace" is "typehinted"
    {"this method returns the validated request values"}
  
  e.g.. {public function store(StorePostRequest $request)}


| Step / Method            | Fail (`false` / invalid)                                                                                                  |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------------- |
| **authorize()**          | Returns `false` → request stops immediately, **403 Forbidden**. Controller never called.                                  |
| **rules() / validation** | Any field fails → Laravel **redirects back** (web) or returns **422** (API). Errors are flashed; controller never called. |


- In order to get the values of the "validated request", you can
  call the "$validated = $request->validated()" in your controller 


  ( Example Code ):   
  
  {"The StorePostRequest file"}

  namespace App\Http\Requests;

  use Illuminate\Foundation\Http\FormRequest;

  class StorePostRequest extends FormRequest
  {
      public function authorize()
      {
          return true;
          // sample: return auth()->user()->id === $this->post->user_id;
      }

      public function rules()
      {
          return [
              'name' => 'required|string|max:255',
              'gender'  => 'required|string',
              'user_id' => 'required|integer|exists:user,id',
          ];
      }
  }


    
  {"The Controller file"}

  namespace App\Http\Controllers;

  use App\Http\Requests\StorePostRequest;

  class UserController extends Controller
  {
      public function store(StorePostRequest $request)
      {
          // The request is already authorized and validated

          // Get only the validated data
          $validated = $request->validated();

          // Pass the validated data to a view
          return view('users.show', ['data' => $validated]);
      }
  }





  
  


